/*******************************************************************************
*   文  件 名：RcuTest.c
*   功     能：测试内核RCU锁功能
*   作     者：zhanxc
*   E-Mail   : zhanxc_chpu@sina.com
*   创建日期：018-7-28
*   修改历史：无
*******************************************************************************/

//https://blog.csdn.net/jus3ve/article/details/79168910
//http://blog.jobbole.com/106856/
//https://blog.csdn.net/andylauren/article/details/70233241
//http://baijiahao.baidu.com/s?id=1584243826171524043&wfr=spider&for=pc
//https://www.cnblogs.com/alantu2018/p/8459359.html

/*******************************************************************************
                             Linux内核RCU锁机制说明
	RCU(Read-Copy Update)，顾名思义就是读-拷贝修改，它是基于其原理命名的。对于被
RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它，但写者在访问它时首先拷贝
一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原
来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享
数据的操作。 
	因此RCU实际上是一种改进的rwlock，读者几乎没有什么同步开销，它不需要锁，不使用
原子指令，而且在除alpha的所有架构上也不需要内存栅（Memory Barrier），因此不会导致锁
竞争，内存延迟以及流水线停滞。不需要锁也使得使用更容易，因为死锁问题就不需要考虑了。
写者的同步开销比较大，它需要延迟数据结构的释放，复制被修改的数据结构，它也必须使用
某种锁机制同步并行的其它写者的修改操作。读者必须提供一个信号给写者以便写者能够确定数
据可以被安全地释放或修改的时机。有一个专门的垃圾收集器来探测读者的信号，一旦所有的读
者都已经发送信号告知它们都不在使用被RCU保护的数据结构，垃圾收集器就调用回调函数完成最
后的数据释放或修改操作。 RCU与rwlock的不同之处是：它既允许多个读者同时访问被保护的数据，
又允许多个读者和多个写者同时访问被保护的数据（注意：是否可以有多个写者并行访问取决于写者
之间使用的同步机制），读者没有任何同步开销，而写者的同步开销则取决于使用的写者间同步机制。
但RCU不能替代rwlock，因为如果写比较多时，对读者的性能提高不能弥补写者导致的损失。 
	读者在访问被RCU保护的共享数据期间不能被阻塞，这是RCU机制得以实现的一个基本前提，也就
说当读者在引用被RCU保护的共享数据期间，读者所在的CPU不能发生上下文切换，spinlock和rwlock
都需要这样的前提。写者在访问被RCU保护的共享数据时不需要和读者竞争任何锁，只有在有多于一个
写者的情况下需要获得某种锁以与其他写者同步。写者修改数据前首先拷贝一个被修改元素的副本，
然后在副本上进行修改，修改完毕后它向垃圾回收器注册一个回调函数以便在适当的时机执行真正的
修改操作。等待适当时机的这一时期称为宽限期(grace period)，而CPU发生了上下文切换称为经历一
个quiescent state，grace period就是所有CPU都经历一次quiescent state所需要的等待的时间。
垃圾收集器就是在grace period之后调用写者注册的回调函数来完成真正的数据修改或数据释放操作的。 
	以下以链表元素删除为例详细说明这一过程。 
	写者要从链表中删除元素 B，它首先遍历该链表得到指向元素 B 的指针，然后修改元素 B 的前一
个元素的 next 指针指向元素 B 的 next 指针指向的元素C，修改元素 B 的 next 指针指向的元素 C 
的 prep 指针指向元素 B 的 prep指针指向的元素 A,在这期间可能有读者访问该链表，修改指针指向的
操作是原子的，所以不需要同步，而元素 B 的指针并没有去修改，因为读者可能正在使用 B 元素来得
到下一个或前一个元素。写者完成这些操作后注册一个回调函数以便在 grace period 之后删除元素 B，
然后就认为已经完成删除操作。垃圾收集器在检测到所有的CPU不在引用该链表后，即所有的 CPU 已经
经历了 quiescent state,grace period 已经过去后，就调用刚才写者注册的回调函数删除了元素 B。

	RCU的API：
	1、rcu_read_lock()
		读者在读取由RCU保护的共享数据时使用该函数标记它进入读端临界区。
	2、rcu_read_unlock()
		该函数与rcu_read_lock配对使用，用以标记读者退出读端临界区
		preempt_disable()：禁止内核抢占
		preempt_enable()：打开内核抢占
		在读端临界区中内核是禁止抢占的。
	3、synchronize_rcu()
		该函数由RCU写端调用，它将阻塞写者，直到经过grace period后，即所有的读者已经完成
	读端临界区，写者才可以继续下一步操作。如果有多个RCU写端调用该函数，他们将在一个
	grace period之后全部被唤醒。注意，该函数在2.6.11及以前的2.6内核版本中为
	synchronize_kernel，只是在2.6.12才更名为synchronize_rcu,但在2.6.12中也提供了
	synchronize_kernel和一个新的函数synchronize_sched，因为以前有很多内核开发者使用
	synchronize_kernel用于等待所有CPU都退出不可抢占区，而在RCU设计时该函数只是用于等待
	所有CPU都退出读端临界区，它可能会随着RCU实现的修改而发生语意变化，因此为了预先防止
	这种情况发生，在新的修改中增加了专门的用于其它内核用户的synchronize_sched函数和只用于
	RCU使用的synchronize_rcu，现在建议非RCU内核代码部分不使用synchronize_kernel而使用
	synchronize_sched，RCU代码部分则使用synchronize_rcu，synchronize_kernel之所以存在
	是为了保证代码兼容性。
	4、synchronize_kernel()
		其他非RCU的内核代码使用该函数来等待所有CPU处在可抢占状态，目前功能等同于
	synchronize_rcu，但现在已经不建议使用，而使用synchronize_sched。
	5、synchronize_sched()
		该函数用于等待所有CPU都处在可抢占状态，它能保证正在运行的中断处理函数处理完毕，
	但不能保证正在运行的softirq处理完毕。注意，synchronize_rcu只保证所有CPU都处理完正在
	运行的读端临界区。

	2.6内核引入了RCU锁，这种锁十分高效，总的说来就是读时加锁，写时拷贝，读后更新。具体的
流程可以参照 rcu的相关文档。本文主要谈一下rcu在linux2.6内核的演变过程，它分别经历了三个
阶段，分别是传统rcu锁，可抢占rcu锁以及2.6.29 中将要引入的树形分层rcu锁。

*******************************************************************************/

