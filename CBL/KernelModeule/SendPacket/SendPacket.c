#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/sched.h>
#include <linux/kthread.h>
#include <linux/kfifo.h>
#include <linux/interrupt.h>
#include <linux/irqreturn.h>
#include <linux/string.h>
#include <linux/vmalloc.h>
#include <linux/skbuff.h>
#include <linux/netdevice.h>
#include <linux/etherdevice.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <linux/inet.h>
#include <linux/udp.h>
#include <linux/tcp.h>
#include <linux/delay.h>

/*******************************************************************************************
	//eth头
	struct ethhdr {
        unsigned char   h_dest[ETH_ALEN];       // destination eth addr
        unsigned char   h_source[ETH_ALEN];     // source ether addr
        __be16          h_proto;                // packet type ID field
	} __attribute__((packed));
	
	//IP头
	struct iphdr {
		#if defined(__LITTLE_ENDIAN_BITFIELD)
			__u8    ihl:4,
			version:4;
		#elif defined (__BIG_ENDIAN_BITFIELD)
			__u8    version:4,
			ihl:4;
		#else
			#error  "Please fix <asm/byteorder.h>"
		#endif
		__u8    tos;
		__be16  tot_len;
		__be16  id;
		__be16  frag_off;
		__u8    ttl;
		__u8    protocol;
		__sum16 check;
		__be32  saddr;
		__be32  daddr;
		//The options start here.
	};
	
	//UDP头
	struct udphdr {
        __be16  source;
        __be16  dest;
        __be16  len;
        __sum16 check;
	};
	//TCP头
	struct tcphdr {
        __be16 source;      //16位源端口号
        __be16 dest;        //16位目的端口号
        __be32 seq;         //表示此次发送的数据在整个报文段中的起始字节数。序号是32 bit的无符号数。为了安全起见，它的初始值是一个随机生成的数，它到达32位最大值后，又从零开始。
        __be32 ack_seq;     //指定的是下一个期望接收的字节，而不是已经正确接收到的最后一个字节。
    #if defined(__LITTLE_ENDIAN_BITFIELD)
        __u16   res1:4,
                doff:4, //TCP头长度，指明了在TCP头部包含多少个32位的字。此信息是必须的，因为options域的长度是可变的，所以整个TCP头部的长度也是变化的。从技术上讲，这个域实际上指明了数据部分在段内部的其起始地址(以32位字作为单位进行计量)，因为这个数值正好是按字为单位的TCP头部的长度，所以，二者的效果是等同的
                fin:1,
                syn:1,
                rst:1,
                psh:1,
                ack:1,
                urg:1,
                ece:1,
                cwr:1;
    #elif defined(__BIG_ENDIAN_BITFIELD)
        __u16   doff:4,
                res1:4,
                cwr:1,
                ece:1,
                urg:1,
                ack:1,
                psh:1,
                rst:1,
                syn:1,
                fin:1;
    #else
    #error "Adjust your <asm/byteorder.h> defines"
    #endif
        __be16 window;  //是16位滑动窗口的大小，单位为字节，起始于确认序列号字段指明的值，这个值是接收端正期望接收的字节数，其最大值是63353字节。
        __be16 check;   //是检验和，覆盖了整个的TCP报文段，这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。
        __be16 urg_ptr; //这个域被用来指示紧急数据在当前数据段中的位置，它是一个相对于当前序列号的字节偏移值。这个设施可以代替中断信息。
    };
********************************************************************************************/

#define SENDPACKET_RESERVE_LEN							2

#define SENDPACKET_BUFFER_MAX_LEN						1500

#define MAC_ADDR_LEN                                    6

/* 定义协议号 */
#define SENDPACKET_UDP_PROTOCOL                         17
#define SENDPACKET_TCP_PROTOCOL                         6

//定义报文发送ID号
static unsigned int g_uiPacketId = 0;

/* 定义内核模块参数 */
static const char *pstSrcMac = "08:00:27:E9:30:B7";
static const char *pstDstMac = "50:7B:9D:71:93:C4";
static const char *pstSrcIp = "192.168.10.22";
static const char *pstDstIp = "192.168.10.125";
static int iSrcPort = 1000;
static int iDstPort = 12345;
static int iPacketLen = 64;
static int iProtocol = SENDPACKET_UDP_PROTOCOL;
static const char *pstIfName = "eth0";

typedef struct SEND_PACKET_ELEM_Tag
{
	unsigned char acSrcMAC[MAC_ADDR_LEN];
	unsigned char acDstMAC[MAC_ADDR_LEN];
	unsigned int uiSrcIp;
	unsigned int uiDstIp;
	unsigned int uiSrcPort;
	unsigned int uiDstPort;
	unsigned int uiPacketLen;
	unsigned int uiProtocol;
	unsigned int uiSendPacketId;
	char *pstSendPacketData;
	struct net_device *pstNetDevice;
} SEND_PACKET_ELEM_S;

static SEND_PACKET_ELEM_S g_stSendPacketElem;

/* 发包内核线程 */
static struct task_struct *pstSendPacketTask;

//源MAC地址
module_param(pstSrcMac, charp, 0644);
MODULE_PARM_DESC(pstSrcMac, "Source MAC Address");

//目的MAC地址
module_param(pstDstMac, charp, 0644);
MODULE_PARM_DESC(pstDstMac, "Destion MAC Address");

//源IP地址
module_param(pstSrcIp, charp, 0644);
MODULE_PARM_DESC(pstSrcIp, "Source IP Address");

//目的IP地址
module_param(pstDstIp, charp, 0644);
MODULE_PARM_DESC(pstDstIp, "Destion IP Address");

//源端口号
module_param(iSrcPort, int, 0644);
MODULE_PARM_DESC(iSrcPort, "Source Port");

//目的端口号
module_param(iDstPort, int, 0644);
MODULE_PARM_DESC(iDstPort, "Destion Port");

//发送包长
module_param(iPacketLen, int, 0644);
MODULE_PARM_DESC(iPacketLen, "Send Packet Length");

//协议
module_param(iProtocol, int, 0644);
MODULE_PARM_DESC(iProtocol, "Send Packet Protocol");

//接口名
module_param(pstIfName, charp, 0644);
MODULE_PARM_DESC(pstIfName, "IfName");


//执行方法
/* sudo insmod ./SendPacket.ko pstSrcMac=00:1A:2B:3C:4D:5E pstDstMac=0A:1B:3C:4D:5E:6F pstSrcIp=192.168.10.100 pstDstIp=192.168.10.200 iSrcPort=1234 iDstPort=4567 iPacketLen=64 */
/* sudo rmmod SendPacket */

static const char acSendPacketData64[64] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F
};

static const char acSendPacketData256[256] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

static const char acSendPacketData512[512] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

static const char acSendPacketData1024[1024] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

static unsigned char CharToData(const char cChar)  
{  
    switch(cChar)  
    {  
		case '0': return 0;  
		case '1': return 1;  
		case '2': return 2;  
		case '3': return 3;  
		case '4': return 4;  
		case '5': return 5;  
		case '6': return 6;  
		case '7': return 7;  
		case '8': return 8;  
		case '9': return 9;  
		case 'a':   
		case 'A': return 10;  
		case 'b':   
		case 'B': return 11;  
		case 'c':  
		case 'C': return 12;  
		case 'd':   
		case 'D': return 13;  
		case 'e':   
		case 'E': return 14;  
		case 'f':  
		case 'F': return 15; 
		default:
			break;
    }
    
    return 0;  
}

static void StrToMac(const char *szMac, unsigned char *pMac)  
{  
    const char *pTemp = szMac;
	int i = 0;
	
    for (i = 0; i < 6; ++i)  
    {  
        pMac[i] = CharToData(*pTemp++) * 16;  
        pMac[i] += CharToData(*pTemp++);  
        pTemp++;  
    }

	return;
}

static void DumpPacket(char *pcBuffer, unsigned int uiBufferLen)
{
	unsigned int i = 0;

	printk("====Dump Packet Begin====\r\n");
	for (i = 0; i < uiBufferLen; i++)
	{
		if ((i != 0) && ((i % 16) == 0))
		{
			printk("\r\n");			
		}
		
		printk("%02x ", (unsigned char)pcBuffer[i]);
	}
	printk("\r\n====Dump Packet End====\r\n");

	return;	
}

static struct sk_buff *SendPacket_Alloc_Skb(struct net_device *pstNetDevice, unsigned int uiSkbDataLen)
{
	struct sk_buff *pstNewSkb = NULL;
	unsigned int uiSkbLen = 0;

	if (NULL == pstNetDevice)
	{
        return NULL;
	}
	
	//uiSkbLen是16字节对齐的
	//GFP_ATOMIC：在中断上下文中使用，代表分配过程不能被中断；
	//GFP_KERNEL：代表分配过程可以被中断，相应的分配请求被放到等待队列中。
	uiSkbLen = sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct udphdr) + uiSkbDataLen;
	uiSkbLen = uiSkbLen + SENDPACKET_RESERVE_LEN;
	
	pstNewSkb = netdev_alloc_skb(pstNetDevice, ((uiSkbLen / 16) + 1) * 16);
    if (NULL == pstNewSkb)
    {
        return NULL;
    }

    pstNewSkb->dev = pstNetDevice;

    /* 头部预留 */
    skb_reserve(pstNewSkb, SENDPACKET_RESERVE_LEN + sizeof(struct ethhdr) +
                            sizeof(struct iphdr) +
                            sizeof(struct udphdr) +
                            uiSkbDataLen);

	return pstNewSkb;
}

static int SendPacketEncapsulation(struct sk_buff *pstSkb, SEND_PACKET_ELEM_S *pstSendPacketInfo)
{
    /* 报文指针 */
    char *pBuff = NULL;
	/* MAC头 */
	struct ethhdr *pstEthHeader = NULL;
	/* IP头 */
	struct iphdr *pstIpHeader = NULL;
	/* UDP头 */
	struct udphdr *pstUdpHeader = NULL;
	/* TCP头 */
	struct tcphdr *pstTcpHeader = NULL;

    /* 参数校验 */
	if (NULL == pstSkb || NULL == pstSendPacketInfo)
	{
        return -1;
	}
	
    /* 构造数据区 */
    pBuff = skb_push(pstSkb, pstSendPacketInfo->uiPacketLen);
    memcpy(pBuff, pstSendPacketInfo->pstSendPacketData, pstSendPacketInfo->uiPacketLen);

    if (SENDPACKET_UDP_PROTOCOL == pstSendPacketInfo->uiProtocol)
    {
        pBuff = skb_push(pstSkb, sizeof(struct udphdr));
        pstUdpHeader = (struct udphdr *)pBuff; 
        /* 填充udphdr字段 */
        pstUdpHeader->source = htons(pstSendPacketInfo->uiSrcPort);                            //源端口号
        pstUdpHeader->dest = htons(pstSendPacketInfo->uiDstPort);                              //目的端口号
        pstUdpHeader->len = htons(sizeof(struct udphdr) + pstSendPacketInfo->uiPacketLen);     //UDP首部加上UDP数据的字节数，最小为8。
        pstUdpHeader->check = 0;                                                               //覆盖UDP首部和UDP数据，是可选的。
    }
    else if (SENDPACKET_TCP_PROTOCOL == pstSendPacketInfo->uiProtocol)
    {
        /* TCP发送报文前需要先建立连接，这里虽然能发送出去，但是实际上格式是不正确的 */
        pBuff = skb_push(pstSkb, sizeof(struct tcphdr));
        pstTcpHeader = (struct tcphdr *)pBuff;
        /* 填充tcphdr字段 */
        pstTcpHeader->source = htons(pstSendPacketInfo->uiSrcPort);
        pstTcpHeader->dest = htons(pstSendPacketInfo->uiDstPort);
        pstTcpHeader->seq = htons(pstSendPacketInfo->uiSendPacketId);
        pstTcpHeader->ack_seq = htons(pstSendPacketInfo->uiSendPacketId++);
    }
    
    skb_reset_transport_header(pstSkb);

    /* 构造IP头 */
    pBuff = skb_push(pstSkb, sizeof(struct iphdr));
    pstIpHeader = (struct iphdr*)pBuff;
    // 填充iphdr字段
    pstIpHeader->version = 4;                           //IPv4
    pstIpHeader->ihl = 5;                               //IP头部长度=5×4=20字节
    pstIpHeader->tos = 0;                               //服务类型，不设置
    pstIpHeader->tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr) + pstSendPacketInfo->uiPacketLen);   //总长度，整个IP数据报的长度，包括首部和数据之和，单位为字节
    pstIpHeader->id = htons(pstSendPacketInfo->uiSendPacketId++);   //标识，主机每发一个报文，加1，分片重组时会用到该字段。
    pstIpHeader->frag_off = htons(0x4000);                          //标志位,不分片
    pstIpHeader->ttl = 6;                                           //生存周期
    pstIpHeader->protocol = (unsigned char)pstSendPacketInfo->uiProtocol;   //UDP
    pstIpHeader->check = 0;                                         //首部校验和，计算时先置0
    pstIpHeader->check = ip_fast_csum((unsigned char *)pstIpHeader, pstIpHeader->ihl);
    pstIpHeader->saddr = pstSendPacketInfo->uiSrcIp;    //源IP地址
    pstIpHeader->daddr = pstSendPacketInfo->uiDstIp;    //目的IP地址

    skb_reset_network_header(pstSkb);

    /* 构造以太头 */
    pBuff = skb_push(pstSkb, sizeof(struct ethhdr));
    pstEthHeader = (struct ethhdr*)pBuff;
    // 填充ethhdr字段
    memcpy(pstEthHeader->h_dest, pstSendPacketInfo->acDstMAC, 6);   //目的MAC地址
    memcpy(pstEthHeader->h_source, pstSendPacketInfo->acSrcMAC, 6); //源MAC地址
    pstEthHeader->h_proto = htons(0x0800);                          //类型，IP报文

    skb_reset_mac_header(pstSkb);

    return 0;
}

/* 发包内核处理句柄 */
static int SendPacketHandler(void *pArg)
{
    struct sk_buff *pstSkbBuff = NULL;
	SEND_PACKET_ELEM_S *pstSendPacketInfo = (SEND_PACKET_ELEM_S *)pArg;
	int iRet = -1;
	
	while (1)
	{
		set_current_state(TASK_UNINTERRUPTIBLE);

		if (kthread_should_stop())
        {
			break;
        }

        if (NULL != pstSendPacketInfo->pstNetDevice)
        {
            /* 分配skb内存 */
        	pstSkbBuff = SendPacket_Alloc_Skb(pstSendPacketInfo->pstNetDevice, pstSendPacketInfo->uiPacketLen);
        	if (NULL == pstSkbBuff)
        	{
        		/* 申请不到skb内存，则直接返回不再继续 */
        		return -1;		
        	}

            iRet = SendPacketEncapsulation(pstSkbBuff, pstSendPacketInfo);
            if (0 != iRet)
            {
                /* 释放skb */
                kfree(pstSkbBuff);
                schedule_timeout(1 * HZ);
                continue;
            }
            
            dev_queue_xmit(pstSkbBuff);

            //DumpPacket(pstSkbBuff->data, pstSkbBuff->len);
    	}

        /* 休眠1ms */
        schedule_timeout(HZ/1000);
	}

	return 0;
}

static int SendPacket_Init(void)
{
	unsigned int uiDataLen = 0;
	char acSendBuffer[SENDPACKET_BUFFER_MAX_LEN] = {0};
	unsigned char acSrcMac[6] = {0};
	unsigned char acDestMac[6] = {0};
	unsigned int uiPacketLen = 0;
	
	printk(KERN_INFO "SendPacket_Init Enter.\n");

	printk(KERN_ALERT "pstSrcMac=%s\r\n", pstSrcMac);
	printk(KERN_ALERT "pstDstMac=%s\r\n", pstDstMac);
	printk(KERN_ALERT "pstSrcIp=%s\r\n", pstSrcIp);
	printk(KERN_ALERT "pstDstIp=%s\r\n", pstDstIp);
	printk(KERN_ALERT "iSrcPort=%d\r\n", iSrcPort);
	printk(KERN_ALERT "iDstPort=%d\r\n", iDstPort);
	printk(KERN_ALERT "iPacketLen=%d\r\n", iPacketLen);
	printk(KERN_ALERT "pstIfName=%d\r\n", pstIfName);
	
	memset(&g_stSendPacketElem, 0, sizeof(SEND_PACKET_ELEM_S));

    /* MAC地址转换 */	
	StrToMac(pstSrcMac, acSrcMac);
	StrToMac(pstDstMac, acDestMac);

	/* 填充g_stSendPacketElem */
	memcpy(g_stSendPacketElem.acDstMAC, acDestMac, MAC_ADDR_LEN);
	memcpy(g_stSendPacketElem.acSrcMAC, acSrcMac, MAC_ADDR_LEN);
	g_stSendPacketElem.uiDstIp = in_aton(pstDstIp);
	g_stSendPacketElem.uiSrcIp = in_aton(pstSrcIp);
	g_stSendPacketElem.uiDstPort = iDstPort;
	g_stSendPacketElem.uiSrcPort = iSrcPort;
	g_stSendPacketElem.uiPacketLen = iPacketLen;
	g_stSendPacketElem.uiSendPacketId = 0;
	g_stSendPacketElem.uiProtocol = iProtocol;
	g_stSendPacketElem.pstNetDevice = dev_get_by_name(&init_net, pstIfName);

	if (64 == iPacketLen)
	{
	    g_stSendPacketElem.pstSendPacketData = &acSendPacketData64[0];
	}
	else if (256 == iPacketLen)
	{
        g_stSendPacketElem.pstSendPacketData = &acSendPacketData256[0];
	}
	else if (512 == iPacketLen)
	{
        g_stSendPacketElem.pstSendPacketData = &acSendPacketData512[0];
	}
	else if (1024 == iPacketLen)
	{
        g_stSendPacketElem.pstSendPacketData = &acSendPacketData1024[0];
	}
	else
	{
        return -1;
	}

    printk("Net device: %p\r\n", g_stSendPacketElem.pstNetDevice);

    /* 起一个内核线程开始发包            */
    pstSendPacketTask = kthread_run(SendPacketHandler, &g_stSendPacketElem, "sendpacket%d", 1);
	if (IS_ERR(pstSendPacketTask)) 
	{
		printk(KERN_INFO "create kthread pstSendPacketTask failed!\n");
	}
	else 
	{
		printk(KERN_INFO "create ktrhead pstSendPacketTask ok!\n");
	}

	printk(KERN_INFO "SendPacket_Init Quite.\n");

	return 0;
}

static void SendPacket_Exit(void) 
{
    int iRet = 0;
    
	printk(KERN_INFO "SendPacket_Exit Enter.\n");

    if (!IS_ERR(pstSendPacketTask))
	{
		iRet = kthread_stop(pstSendPacketTask);
		printk(KERN_INFO "thread function exit %d\n", iRet);
	}

	printk(KERN_INFO "SendPacket_Exit Quite.\n");

	return;
}

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("aggr mode test");
MODULE_AUTHOR("zhanxc");

module_init(SendPacket_Init);
module_exit(SendPacket_Exit);


